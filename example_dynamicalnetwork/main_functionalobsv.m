%% Example of minimum sensor placement and minimum-order functional
% observer design for a random complex dynamical networks.

% This code examplifies how to:
%   (1) apply Algorithm 1 to determine the minimum set of sensor nodes for
%       functional observability of a dynamical network with respecto to
%       a given set of target nodes; and
%   (2) apply Algorithm 2 to design a minimum-order functional observer.
%
% Both algorithms are further described in Ref. [1] and codes "find_msp.m"
% and "find_F0.m".
%
%
% References:
%
%   [1] A. N. Montanari, C. Duan, L. A. Aguirre, A. E. Motter. Functional
%       observability and target state estimation in large-scale networks.

% Copyright (C) 2020  Arthur Montanari
% 
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or (at
% your option) any later version.
% 
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.
% 
% The full text of the GNU General Public License can be found in the 
% file license.txt.

%   Last modified by Arthur Montanari on 16/07/2021

clear all; close all; clc;
addpath('..');

%% Numerical setup.
% This section provides the numerical setup for the random complex
% dynamical networks studied in the main manuscript.

% Loads the adjacency matrix of a Newman-Watts small-world network with
% N = 100 nodes and probability of adding a new edge p = 0.2.
load Adj_SW_n100.mat;
N = size(Adj,2);                           % network size N

% A directed network model is generated by randomly assigning a single
% direction to each edge.
[A_upp1,A_upp2] = find(triu(Adj));
for k = 1:size(A_upp1,1)
    if rand <= 0.2
        Adj(A_upp1(k),A_upp2(k)) = 0;
    else
        Adj(A_upp2(k),A_upp1(k)) = 0;
    end
end

% Each node of the small-world network has a 3-dimensional subsystem with
% the following structure (Eq. 14):
A_node = [-1 -1 0; 1 -1 0; 1 0 -1];

% The dynamical matrix A describing the whole dynamical network is defined
% by Eq. 15:
lambda = 2 + (5-2).*rand(N,1);   % this parameter accounts for the
                                 % effects of heterogeneity in the nodal
                                 % dynamics of the network, where
                                 % A_i = lambda_i*A_node, and lambda_i
                                 % is a random parameter within interval
                                 % [2,5].                                
L = Adj - speye(N).*sum(Adj,2);  % Laplacian matrix corresponding to the
                                 % adjacency matrix of the small-world net.
M = sparse([0 0 0; 0 1 0; 0 0 0]);  % Coupling matrix
A = kron(sparse(diag(lambda)), sparse(A_node)) - kron(L,M);
n = size(A,1);                   % size of dynamical system A (n = 3N)

% Target nodes. Randomly assigned under the constrain that only the first 
% state variable of each subsystem can be chosen  as a target node (i.e., 
% only the first state variable of subsystem A_1, A_2, ..., A_N).
node_sample = datasample(1:3:n-2,N,'Replace',false);
r = 0.3*N;                       % size of the target set
T = node_sample(1:r);            % set of target nodes

%% Algorithm 1: Minimum sensor placement for functional observability

% Set of candidate nodes for sensor placement. We assume that the first
% variable of each subsystem is a candidate for sensor placement.
Cand = node_sample(1:N);         % target nodes can be sensor candidates
% Cand = node_sample(r+1:N);     % target nodes cannot be sensor cands.

% Runs Algorithm 1, which returns the minimum set of sensor nodes S.
S = find_msp(A,T,Cand);

%% Algorithm 2: Minimum-order functional observer design

% Defines output matrix C based on the sensor allocation in Algorithm 1
q = length(S);
C = sparse(1:q,S,1,q,n);

% Defines functional matrix F based on the target nodes of interest
F = sparse(1:r,T,1,r,n);

% Checks if the system is structurally functional observable (Eq. 3)
if sprank([obsv(A,C); F]) == sprank(obsv(A,C))
    disp(['Triple (A,C,F) is structurally functional observable.'])
    
    % Runs Algorithm 2, which returns a minimum-order functional observer
    F0 = find_F0(A,C,F);          % returns matrix F0, which defines
                                  % the functional observer minimum
                                  % order and structure
    [foN,foJ,foH,foD,foE] = functobsv_design(A,C,F0); 
                                  % returns design matrices (N,J,H,D,E)
                                  % of the functional observer (Eq. 9)
                                            
    % Checks if Darouach's condition (4) is satisfied (Eq. 4)
    if sprank([C; C*A; F0]) == sprank([C; C*A; F0; F0*A])
        disp(['Condition (4) is satisfied.'])
        disp(['Functional observer was designed successfully.'])
    else
        disp(['Condition (4) is NOT satisfied.'])
    end
else
    disp(['Triple (A,C,F) is NOT structurally functional observable.'])
    disp(['Functional observer cannot be designed.'])
end

%% Results

% Plots graph of the network system, highlighting sensor and target nodes
figure(1)
subplot(121)
h1 = plot(digraph(A'),'Layout','circle');
highlight(h1,1:n,'NodeColor','black')
highlight(h1,S,'NodeColor',[0.4660 0.6740 0.1880])
highlight(h1,T,'NodeColor',[0.6350 0.0780 0.1840])
title('Dynamical system overview (state variables represented by nodes)')

subplot(122)
h2 = plot(digraph(Adj'),'Layout','circle');
highlight(h2,1:N,'NodeColor','black')
highlight(h2,ceil(S/3),'NodeColor',[0.4660 0.6740 0.1880])
highlight(h2,ceil(T/3),'NodeColor',[0.6350 0.0780 0.1840])
highlight(h2,ceil(T(ismember(T,S))/3),'NodeColor',[0.3010 0.7450 0.9330])
title('Network system overview (subsystems represented by nodes)')

% Note that A is transposed in the code since MATLAB defines an adjacency
% matrix as A(i,j) = 1 if node i points to j, while we use the convention,
% in Ref. [1], that A(i,j) = 1 if node j points to i.
